%{
#include "sspascal.tab.h"
%}

%option noyywrap
%option caseless

LETTER		[A-Za-z_]
DIGIT_ZEC	[0-9]
DIGIT_NZ    [1-9]
ZERO        [0]  
UNDERLINE	"\_"
NR_REAL		{NR_BASE10}"."{NR_BASE10}*
BOOLEAN		"true"|"false"
NR_BASE10	("+"|"-"){DIGIT_NZ}+{DIGIT_ZEC}*|{ZERO}|{DIGIT_NZ}+{DIGIT_ZEC}*
IDENTIFIER	{LETTER}{LETTER}*{DIGIT_ZEC}*|{UNDERLINE}{LETTER}{LETTER}*{DIGIT_ZEC}*
DELIMIT_1	[;.,:<>]
OPERATOR_1	[+*/(){}<>=]|"-"|"["|"]"
SIR_CAR		[\"][^\n]*({UNDERLINE}|{LETTER}|{DIGIT_ZEC})*[\"]
CARACTER	"'"[^\n]({UNDERLINE}|{LETTER}|{DIGIT_ZEC})"'"
ERR_CIFRA_START [0-9]+[a-zA-Z0-9]*
DOT             "\."
COLON           "\:"
SEMICOLON       "\;"								
COMMA           "\,"



%%

[ \t\n]

list		{return LIST;}
const		{return CONST;}
if		{return IF;}
else		{return ELSE;}
write		{return WRITE;}
read		{return READ;}
var		{return VAR;}
while		{return WHILE;}
for			{return FOR;}

char		{return CHAR;}
int		{return INTEGER;}
float		{return REAL;}
bool		{return BOOLEAN;}

"=="	{return EQ;}
"="		{return ATRIB;}
"!="		{return NE;}
"<="		{return LE;}
">="		{return GE;}
div		{return DIV;}
"%"		{return MOD;}
or		{return OR;}
and		{return AND;}
not		{return NOT;}

{IDENTIFIER}	{return ID;}
{NR_BASE10}	{
	yylval.p_val = yytext;
	return CONST_INT;
		}
{NR_REAL}	{
	yylval.p_val = yytext;
	return CONST_REAL;
		}
{CARACTER}	{
	yylval.p_val = yytext;
	return CONST_CAR;
		}
{SIR_CAR}	{return CONST_SIR;}


{DELIMIT_1}	{return yytext[0];}
{OPERATOR_1}	{return yytext[0];}


[ \t\n]+ {}
(\+0|\-0) {printf("Lexical error - sign before zero %s at line %d \n", yytext, yylineno);}
. printf("Eroare %s la linia %d\n", yytext, yylineno);
[0-9]+[a-zA-Z]+[a-zA-Z0-9]* {printf("Lexical error - identifier starts with digit %s at line %d \n", yytext, yylineno);}

%%

